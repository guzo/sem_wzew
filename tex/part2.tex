%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Konkretne przykłady} %FIXME: mniej głupia nazwa
\begin{frame}[fragile, allowframebreaks]{Przykładowe optymalizacje}
	\begin{block}{Wybór algorytmu/architektury}
		\begin{itemize}
			\item Złożoność obliczeniowa
				\begin{itemize}
					\item indeksowanie w bazach danych (nlgn+klgn vs. kn)
					\item QS/SS, fallback
					\item QS/HS
					\item custom heap w QS
					\item buforowanie (przykład)
					\item fajne-na-papierze-niepraktyczne-w-realu mnozenia macierzy: \url{http://en.wikipedia.org/wiki/File:Bound_on_matrix_multiplication_omega_over_time.svg}
				\end{itemize}
			\item Lazy evaluation
			\item Memory access patterns
				\begin{itemize}
					\item AoS vs. SoA, row/column major
					\item cache aware (liniowo, reuse, jawny prefetch)
					\item cache oblivious
				\end{itemize}
		\end{itemize}
	\end{block}
	\begin{block}{Na poziomie kodu źródłowego}
		\begin{itemize}
			\item inlining
				\begin{itemize}
					\item enabling transform dla m.in. zwijania/optymalizacji wykorzystania rejestrów
					\item przy małych funkcjach (gettery!) - więcej kodu na wywołanie i sprzątanie niż na ciało
					\item funkcje użyte tylko raz (bo przejrzystość) (static)
				\end{itemize}
			\item loop unrolling
				\begin{itemize}
					\item trochę pokrewne z inline
					\item I\$
					\item dawniej: Duff's device
					\item \#pragma - intel
					\item \verb*%BOOST_PP%
				\end{itemize}
			\item tail recursion elimination
			\item dead code elimination
			\item jump threading
		\end{itemize}
	\end{block}
	\begin{block}{Na poziomie IR}
		\begin{itemize}
			\item dead code elimination
				\begin{itemize}
					\item available expression analysis
					\item live variable analysis
					\item global value numbering
				\end{itemize}
			\item peephole/window optimization (kategoria)
				\begin{itemize}
					\item strength reduction (demo)
					\item constant folding
				\end{itemize}
			\item tail recursion elimination
			\item jump threading
		\end{itemize}
	\end{block}
	\begin{block}{Na poziomie asm/przejście z IR}
		\begin{itemize}
			\item register allocation
				\begin{itemize}
					\item available expression analysis
					\item live variable analysis
					\item global value numbering
				\end{itemize}
			\item instruction selection - jedna z metod strength reduction
				\begin{itemize}
					\item lea zamiast prostych mnozen (bez side effcts, ustalone argumenty)
					\item "Like any good optimization, it makes the implementation a bit messier, but doesn't affect the interface."
					\item shifty zamiast mnozen/dzielen przez 2**n
					\item xor reg, reg vs. mov reg, 0
					\item "Division by Invariant Integers using Multiplication"
					\item http://www.nynaeve.net/?p=64
					\item prostsza matematyka: 	-fast-math, flush to 0, denorm, takietam,	bitshifty zamiast mnozen
					\item demo: \verb*%src/common/common_optimizations.ctel%
				\end{itemize}
			\item callconv
			\item vectorization
			\item -mtune
			\item stack reuse
		\end{itemize}
	\end{block}
	\begin{block}{Runtime}
		python, etc
	\end{block}
\end{frame}
%FIXME why do you insist, LaTeX?
\begin{frame}[fragile, allowframebreaks]{Pętle}
	Dlaczego osobno?
	\begin{block}{Memory access - istotne, warto pomóc}
		\begin{itemize}
			\item tiling/loop nest optimization: matmul
			\item stripmining $=>$ automatic parallelisation/vectorisation - matmul
				\begin{itemize}
					\item dependencies (aliasing)
					\item OpenMP
				\end{itemize}
			\item loop unrolling: matmul
			\item loop interchange: matmul (row/column major)
			\item loop fusion/fission
			\item szczególne przypadki
				\begin{itemize}
					\item splitting
					\item peeling
					\item unswitching
				\end{itemize}
		\end{itemize}
	\end{block}
	\begin{block}{Drobne, czasem warto zostawić}
		\begin{itemize}
			\item factoring out of invariants
			\item loop invariant code motion
			\item induction variable elimination (była mowa)
			\item rematerialization (troche jak xor reg,reg)
			\item bounds checking elimination
		\end{itemize}
	\end{block}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Enabling Transformations}
	%FIXME: merge
	\begin{block}{Loop unrolling}
		\begin{itemize}
		 \item Polega na rozwinięciu zagnieżdżonych pętli do dwuwymiarowej struktury zwanej
		 wielokomórką.
		\end{itemize}
	\end{block}
	\begin{block}{Przykład}
		Przykład?
	\end{block}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Enabling Transformations}
	%FIXME: merge
	\begin{block}{Loop unwiding} %FIXME nie podoba mi się ta optymalizacja - może by ją usunąć?
	%A: absolutnie nie, bo jest upiornie istotna. Optymalizacje niemal z definicji "brzydkie"
		\begin{itemize}
		 \item Polega wykonaniu kilku ``równorzędnych'' instrukcji w jednej pętli, przez co pomijane jest
		 sprawdzanie warunku stopu.
		\end{itemize}
	\end{block}
	\begin{block}{Przykład}
		\begin{cpp}
		for (int x = 0; x < (int)1e8;)

		    do_something(x);
		}
		for (int x = 0; x < (int)1e8;)
		{
		    do_something(x);
		    do_something(++x);
		    do_something(++x);
		    do_something(++x);
		}
		\end{cpp}
	\end{block}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
